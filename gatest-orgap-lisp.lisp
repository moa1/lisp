;;; organism implementation in lisp

(defstruct (orgap
	     (:constructor make-orgap*))
  genes ;genes of the organism
  code ;compiled code
  markers ;ALIST of IPs by marker number
  ip
  wait
  (angle 0.0)
  x
  y
  energy
  off-genes
  off-length
  as
  bs
  an
  bn
  genesx ;rest of the genes to be read
  )

(defun make-orgap (genes x y energy)
  (labels ((compile-genes (genes)
	     ;; TODO: FIXME: this function is a steaming pile of shit; nobody can figure out the control flow.
	     (declare (optimize (debug 3)))
	     (labels ((return-defaults ()
			(return-from compile-genes (make-array 0))))
	       (multiple-value-bind (code markers jnes)
		   (let ((markers nil)
			 (jnes nil)
			 (code nil)
			 (code-ip 0))
		     (loop do
			  (labels ((next ()
				     (if (null genes)
					 (let* ((rev (nreverse code))
						(new (make-array (length rev) :initial-contents rev)))
					   (return (values new markers jnes)))
					 (let ((a (car genes)))
					   (setf genes (cdr genes))
					   a))))
			    (let* ((g (next))
				   (gs (string g)))
			      ;;(prind g code-ip)
			      (cond
				((equal (subseq gs 0 3) "MRK")
				 (let* ((rest (subseq gs 3))
					(pos (assoc rest markers)))
				   (when (null pos)
				     (let ((label (if (equal "" rest) nil (read-from-string rest))))
				       (when (not (typep label 'fixnum))
					 (return-defaults))
				       (setf markers (acons label code-ip markers))))))
				((equal (subseq gs 0 3) "JNE")
				 (let* ((rest (subseq gs 3))
					(pos (assoc rest markers)))
				   (when (null pos)
				     (let ((label (if (equal "" rest) nil (read-from-string rest))))
				       (when (not (typep label 'fixnum))
					 (return-defaults))
				       (push g code)
				       (push label jnes)))))
				(t
				 (push g code)
				 (incf code-ip)))))))
		 #|
		 (prind code)
		 (prind markers)
		 (prind jnes)
		 |#
		 (loop for jne-label in jnes do
		      ;;(prind (assoc jne-label markers))
		      (when (null (assoc jne-label markers))
			(return-defaults)))
		 (values code markers)))))
    (multiple-value-bind (code markers) (compile-genes genes)
      (make-orgap* :genes genes :code code :markers markers :ip 0 :wait 0 :x x :y y :energy energy :off-genes nil :off-length 0 :as nil :bs nil :an 0 :bn 0 :genesx genes))))

(defun clamp (x min max)
  (min (max x min) max))

(defun my-mod (x y)
  ;;(nth-value 1 (round x y))
  (multiple-value-bind (quotient remainder) (floor x y)
    (if (and (= quotient -1) (>= (abs remainder) (abs y)))
	(+ remainder (* quotient y))
	remainder)))

(defun eval-orgap (iters org)
  (declare (optimize (debug 3)))
  (with-slots (genes code markers ip wait angle x y energy off-genes off-length as bs an bn genesx) org
    (let* ((offspring nil)
	   (max-ip (1- (array-dimension code 0)))
	   (world-w (array-dimension *world* 0))
	   (world-h (array-dimension *world* 1))
	   (pi/2 (/ pi 2)))
      (labels ((die (reason)
		 (declare (ignorable reason))
		 ;;(prind "dies" reason org)
		 (return-from eval-orgap (values :kill offspring)))
	       (survive ()
		 (return-from eval-orgap (values :survive offspring)))
	       (cell-division (off-x off-y off-energy)
		 (when (<= (random 100) 0)
		   (setf off-energy (random (1+ energy))))
		 (setf off-genes (nreverse off-genes))
		 (setf off-energy (min energy (max (floor off-energy) 0)))
		 (setf off-x (mod off-x world-w))
		 (setf off-y (mod off-y world-h))
		 ;;(format t "cell-division x:~A y:~A energy:~A off:~A~%" off-x off-y off-energy off)
		 (push (make-orgap off-genes off-x off-y off-energy) offspring)
		 (decf energy off-energy)
		 ;;(push (make-orgap off-genes x y (- energy off-energy)) offspring)
		 ;;(setf energy 0) ;to be sure ORG is dead.
		 (setf off-genes nil)
		 (setf off-length 0)
		 (setf genesx genes)
		 ;;(die)
		 ))
	(loop for i below iters do
	     (when (> wait 0)
	       (let ((skip (min wait (- iters i))))
		 (decf wait skip)
		 (incf i skip))
	       (when (> wait 0)
		 (survive)))
	     (tagbody
	      next-ins
		(when (or (> ip max-ip))
		  (die "ip too large"))
		(when (<= energy 0)
		  (die "out of energy"))
		;;(when (<= (random 100000) 1)
		;;  (setf ip (random (length code))))
		(let* ((ins (aref code ip)))
		  ;;(prind energy ip ins as bs an bn off-genes)
		  (decf energy)
		  (macrolet ((make-instructions (keyform &body cases)
			       (let* ((instructions-list (mapcar #'caar cases))
				      (n-labels 4)
				      (markers-list (loop for i below n-labels collect
							 (intern (format nil "MRK~A" i))))
				      (i-list (append instructions-list markers-list))
				      (instructions (make-array (length i-list) :initial-contents i-list))
				      (instructions-hash-table (make-hash-table :test 'eq))
				      (keyform-sym (gensym)))
				 (loop for ins in i-list do
				      (setf (gethash ins instructions-hash-table) t))
				 (let ((code
					`(labels ((random-ins ()
						    (sample ,instructions))
						  (is-valid-ins (ins)
						    (multiple-value-bind (val present)
							(gethash ins ,instructions-hash-table)
						      (declare (ignore val))
						      present)))
					   (let ((,keyform-sym ,keyform))
					     (ecase ,keyform-sym
					       ,@cases
					       ((end))
					       ))
					   )))
				   ;;(prind code)
				   ;;(prind instructions)
				   code))))
		    (make-instructions
		     ins
		     ((eat)
		      (let ((x (floor x))
			    (y (floor y)))
			(incf energy (aref *world* x y))
			(setf (aref *world* x y) 0)
			(setf wait 10000)))
		     ((set-as-nil)
		      (setf as nil))
		     ((set-bs-nil)
		      (setf bs nil))
		     ((set-as-random)
		      (setf as (random-ins)))
		     ((set-bs-random)
		      (setf bs ;;(random-ins)
			    'set-bs-random
			    ))
		     ((read-as)
		      (setf as (if (<= (random 1000) 0) (random-ins) (car genesx))))
		     ((read-bs)
		      (setf bs (if (<= (random 2000) 0) (random-ins) (car genesx))))
		     ((read-next)
		      (setf genesx (cdr genesx)))
		     ((write-as)
		      (when (is-valid-ins as)
			(when (> off-length 100000)
			  (die "offspring too big"))
			(let ((r (random 1000)))
			  (cond ((= r 0) (push (random-ins) off-genes) (push as off-genes) (incf off-length 2))
				((= r 1) (push as off-genes) (push (random-ins) off-genes) (incf off-length 2))
				((<= r 3) nil)
				(t (push as off-genes) (incf off-length))))))
		     ((write-bs)
		      (when (is-valid-ins bs)
			(when (> off-length 100000)
			  (die "offspring too big"))
			(let ((r (random 1000)))
			  (cond ((= r 0) (push (random-ins) off-genes) (push bs off-genes) (incf off-length 2))
				((= r 1) (push bs off-genes) (push (random-ins) off-genes) (incf off-length 2))
				((<= r 3) nil)
				(t (push bs off-genes) (incf off-length))))))
		     ;; (when (is-valid-ins bs)
		     ;;   (when (> off-length 100000)
		     ;;     (die))
		     ;;   (push bs off-genes)
		     ;;   (incf off-length)))
		     ((cmp-as-bs)
		      (setf as (eq as bs)))
		     ((cmp-gt-an-bn)
		      (setf as (> an bn)))
		     ((cmp-gt-bn-an)
		      (setf as (> bn an)))
		     ((jne0)
		      (when (not as)
			(let* ((jump-ip (cdr (assoc 0 markers)))) ;0 because of JNE_0_
			  (setf ip jump-ip)
			  (if (<= 0 ip max-ip)
			      (go next-ins)
			      (die "invalid jump target")))))
		     ((jne1)
		      (when (not as)
			(let* ((jump-ip (cdr (assoc 1 markers)))) ;0 because of JNE_0_
			  (setf ip jump-ip)
			  (if (<= 0 ip max-ip)
			      (go next-ins)
			      (die "invalid jump target")))))
		     ((jne2)
		      (when (not as)
			(let* ((jump-ip (cdr (assoc 2 markers)))) ;0 because of JNE_0_
			  (setf ip jump-ip)
			  (if (<= 0 ip max-ip)
			      (go next-ins)
			      (die "invalid jump target")))))
		     ((set-an-1)
		      (setf an 1))
		     ((set-bn-1)
		      (setf bn 1))
		     ((add-to-an-bn)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf an (the fixnum (+ an bn)))))
		     ((add-to-bn-an)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf bn (the fixnum (+ an bn)))))
		     ((mul-to-an-bn)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf an (the fixnum (* an bn)))))
		     ((mul-to-bn-an)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf bn (the fixnum (* an bn)))))
		     ((sub-from-an-bn)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf an (the fixnum (- an bn)))))
		     ((sub-from-bn-an)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf bn (the fixnum (- bn an)))))
		     ((sign-an)
		      (setf an (signum an)))
		     ((sign-bn)
		      (setf bn (signum bn)))
		     ;; TODO: FIXME: take energy relative to current angle, not absolute coordinates.
		     ((in-energy-left-an)
		      (let ((x (mod (+ x (* (cos (- angle pi/2)) 3)) world-w))
			    (y (mod (+ y (* (sin (- angle pi/2)) 3)) world-h)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-energy-right-an)
		      (let ((x (mod (+ x (* (cos (+ angle pi/2)) 3)) world-w))
			    (y (mod (+ y (* (sin (+ angle pi/2)) 3)) world-h)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-energy-left-bn)
		      (let ((x (mod (+ x (* (cos (- angle pi/2)) 3)) world-w))
			    (y (mod (+ y (* (sin (- angle pi/2)) 3)) world-h)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-energy-right-bn)
		      (let ((x (mod (+ x (* (cos (+ angle pi/2)) 3)) world-w))
			    (y (mod (+ y (* (sin (+ angle pi/2)) 3)) world-h)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-energy-x+an)
		      (let ((x (mod (+ x 3) world-w)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-energy-x-an)
		      (let ((x (mod (- x 3) world-w)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-energy-y+an)
		      (let ((y (mod (+ y 3) world-h)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-energy-y-an)
		      (let ((y (mod (- y 3) world-h)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-energy-x+bn)
		      (let ((x (mod (+ x 3) world-w)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-energy-x-bn)
		      (let ((x (mod (- x 3) world-w)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-energy-y+bn)
		      (let ((y (mod (+ y 3) world-h)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-energy-y-bn)
		      (let ((y (mod (- y 3) world-h)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-angle-an)
		      (setf an (round (* 128 (mod angle (* pi 2))))))
		     ((in-angle-bn)
		      (setf bn (round (* 128 (mod angle (* pi 2))))))
		     ((set-as-an-gt0)
		      (setf as (> an 0)))
		     ((set-as-an-ge0)
		      (setf as (>= an 0)))
		     ((set-an-max-an-bn)
		      (setf an (max an bn)))
		     ((set-bn-max-an-bn)
		      (setf bn (max an bn)))
		     ((split-cell-an)
		      (when (and (>= an 0) (>= energy an))
			(cell-division x y an)))
		     ((split-cell-bn)
		      (when (and (>= bn 0) (>= energy bn))
			(cell-division x y bn)))
		     ((turn-cw-an)
		      (incf angle (/ an 128))
		      (setf wait 300))
		     ((turn-cw-bn)
		      (incf angle (/ bn 128))
		      (setf wait 300))
		     ((turn-ccw-an)
		      (decf angle (/ an 128))
		      (setf wait 300))
		     ((turn-ccw-bn)
		      (decf angle (/ bn 128))
		      (setf wait 300))
		     ((walk-an)
		      (let ((new-x (my-mod (+ x (* (cos angle) (clamp (/ an 128) -1 1))) world-w))
			    (new-y (my-mod (+ y (* (sin angle) (clamp (/ an 128) -1 1))) world-h)))
			(when (>= (aref *world* (floor new-x) (floor new-y)) 0)
			  (setf x new-x y new-y)))
		      (setf wait 300))
		     ((walk-bn)
		      (let ((new-x (my-mod (+ x (* (cos angle) (clamp (/ bn 128) -1 1))) world-w))
			    (new-y (my-mod (+ y (* (sin angle) (clamp (/ bn 128) -1 1))) world-h)))
			(when (>= (aref *world* (floor new-x) (floor new-y)) 0)
			  (setf x new-x y new-y)))
		      (setf wait 300))
#|		      (setf x (mod (+ x (* (cos angle) (clamp (/ bn 128) -1 1))) world-w))
		      (setf y (mod (+ y (* (sin angle) (clamp (/ bn 128) -1 1))) world-h))
		      (setf wait 300))|#
#|		     ((walk-x-an)
		      (let ((new-x (mod (- x (clamp an -1 1)) world-w)))
			(when (>= (aref *world* (floor new-x) (floor y)) 0)
			  (setf x new-x)))
		      (setf wait 300))
		     ((walk-y-an)
		      (let ((new-y (mod (- y (clamp an -1 1)) world-h)))
			(when (>= (aref *world* (floor x) (floor new-y)) 0)
			  (setf y new-y)))
		      (setf wait 300))
		     ((walk-x+an)
		      (let ((new-x (mod (+ x (clamp an -1 1)) world-w)))
			(when (>= (aref *world* (floor new-x) (floor y)) 0)
			  (setf x new-x)))
		      (setf wait 300))
		     ((walk-y+an)
		      (let ((new-y (mod (+ y (clamp an -1 1)) world-h)))
			(when (>= (aref *world* (floor x) (floor new-y)) 0)
			  (setf y new-y)))
		      (setf wait 300))
|#
		     ((set-angle-right)
		      (setf angle 0))
		     ((set-angle-down)
		      (setf angle (/ pi 2)))
		     ((set-angle-left)
		      (setf angle pi))
		     ((set-angle-up)
		      (setf angle (* pi 3/2)))
		     ((wait-an)
		      ;;(prind "wait" an)
		      (setf wait (min (max (floor an) 0) 100000))
		      )
		     ((wait-bn)
		      (setf wait (min (max (floor bn) 0) 100000))
		      )
		     ))
		  (assert (and (typep an 'fixnum) (typep bn 'fixnum)) (an bn) "AN:~A or BN:~A are not of type FIXNUM (last INS:~A)." an bn ins)
		  )
		(incf ip)))
	(survive)
	))))

(defun orgap-code-length (org)
  (array-dimension (orgap-code org) 0))

;; the slot accessors for ORGAP do not have to be defined.

;;; end of organism implementation
