;;; organism implementation in lisp

(defstruct (orgap
	     (:constructor make-orgap*))
  genes ;genes of the organism
  code ;compiled code
  markers ;ALIST of IPs by marker number
  (ip 0)
  (wait 0)
  (angle 0.0)
  (target nil)
  (targeter nil)
  x
  y
  energy
  (skin 1)
  (off-genes nil)
  (off-length 0)
  (as nil)
  (bs nil)
  (an 0)
  (bn 0)
  (memory (make-array 2 :initial-element 0))
  genesx ;rest of the genes to be read
  ;; statistics
  (walk-sum 0.0)
  (walk-count 0)
  (kills 0)
  )

(defmethod print-object ((org orgap) stream)
  (print-unreadable-object (org stream :type t :identity t)
    (format stream ":GENES ~S~%:IP ~S~%:WAIT ~S~%:ANGLE ~S~%:TARGET ~S~%:X ~S~%:Y ~S~%:ENERGY ~S~%:SKIN ~S~%:OFF-GENES ~S~%:AS ~S~%:BS ~S~%:AN ~S~%:BN ~S"
	    (orgap-genes org) (orgap-ip org) (orgap-wait org) (orgap-angle org) (when (orgap-target org) (orgcont-id (orgap-target org))) (orgap-x org) (orgap-y org) (orgap-energy org) (orgap-skin org) (orgap-off-genes org) (orgap-as org) (orgap-bs org) (orgap-an org) (orgap-bn org))))

(defun make-orgap (genes x y energy)
  (labels ((compile-genes (genes)
	     ;; TODO: FIXME: this function is a steaming pile of shit; nobody can figure out the control flow.
	     (declare (optimize (debug 3)))
	     (labels ((return-defaults ()
			(return-from compile-genes (make-array 0))))
	       (multiple-value-bind (code markers jumps)
		   (let ((markers nil)
			 (jumps nil)
			 (code nil)
			 (code-ip 0))
		     (loop do
			  (labels ((next ()
				     (if (null genes)
					 (let* ((rev (nreverse code))
						(new (make-array (length rev) :initial-contents rev)))
					   (return (values new markers jumps)))
					 (let ((a (car genes)))
					   (setf genes (cdr genes))
					   a))))
			    (let* ((g (next))
				   (gs (string g)))
			      ;;(prind g code-ip)
			      (cond
				((equal (subseq gs 0 3) "MRK")
				 (let* ((rest (subseq gs 3))
					(pos (assoc rest markers)))
				   (when (null pos)
				     (let ((label (if (equal "" rest) nil (read-from-string rest))))
				       (when (not (typep label 'fixnum))
					 (return-defaults))
				       (setf markers (acons label code-ip markers))))))
				((equal (subseq gs 0 3) "JNE")
				 (let* ((rest (subseq gs 3))
					(pos (assoc rest markers)))
				   (when (null pos)
				     (let ((label (if (equal "" rest) nil (read-from-string rest))))
				       (when (not (typep label 'fixnum))
					 (return-defaults))
				       (push g code)
				       (push label jumps)))))
				((equal (subseq gs 0 3) "JMP")
				 (let* ((rest (subseq gs 3))
					(pos (assoc rest markers)))
				   (when (null pos)
				     (let ((label (if (equal "" rest) nil (read-from-string rest))))
				       (when (not (typep label 'fixnum))
					 (return-defaults))
				       (push g code)
				       (push label jumps)))))
				(t
				 (push g code)
				 (incf code-ip)))))))
		 #|
		 (prind code)
		 (prind markers)
		 (prind jumps)
		 |#
		 (loop for jump-label in jumps do
		      ;;(prind (assoc jump-label markers))
		      (when (null (assoc jump-label markers))
			(return-defaults)))
		 (values code markers)))))
    (multiple-value-bind (code markers) (compile-genes genes)
      (make-orgap* :genes genes :code code :markers markers :x x :y y :energy energy :genesx genes))))

(defun clamp (x min max)
  (assert (>= max min))
  (min (max x min) max))

(defun my-mod (x y)
  ;;(nth-value 1 (round x y))
  (multiple-value-bind (quotient remainder) (floor x y)
    (if (and (= quotient -1) (>= (abs remainder) (abs y)))
	(+ remainder (* quotient y))
	remainder)))

(defun eval-orgap (iters org orgcont)
  (declare (optimize (debug 3)))
  (with-slots (genes code markers ip wait angle target targeter x y energy skin off-genes off-length as bs an bn genesx walk-sum walk-count kills) org
    (let* ((offspring nil)
	   (max-ip (1- (array-dimension code 0)))
	   (world-w (array-dimension *world* 0))
	   (world-h (array-dimension *world* 1))
	   (pi/2 (/ pi 2)))
      (labels ((die (reason)
		 (declare (ignorable reason))
		 ;;(prind "dies" reason org)
		 (let ((x (floor x))
		       (y (floor y)))
		   (incf (aref *world* x y) (max energy 0))
		   (setf energy 0))
		 (return-from eval-orgap (values :kill offspring)))
	       (survive ()
		 (if (>= (orgcont-age orgcont) 2000000)
		     (die "too old")
		     (return-from eval-orgap (values :survive offspring))))
	       (cell-division (off-x off-y off-energy)
		 (when (<= (random 100) 0)
		   (setf off-energy (random (1+ energy))))
		 (setf off-genes (nreverse off-genes))
		 (setf off-energy (clamp off-energy 0 energy))
		 (setf off-x (mod off-x world-w))
		 (setf off-y (mod off-y world-h))
		 ;;(format t "cell-division x:~A y:~A energy:~A off:~A~%" off-x off-y off-energy off)
		 (let ((off-orgap (make-orgap off-genes off-x off-y off-energy)))
		   (push off-orgap offspring)
		   (incf (orgap-wait off-orgap) 20000)
		   (incf wait 20000))
		 (decf energy off-energy)
		 ;;(push (make-orgap off-genes x y (- energy off-energy)) offspring)
		 ;;(setf energy 0) ;to be sure ORG is dead.
		 (setf off-genes nil)
		 (setf off-length 0)
		 (setf genesx genes)
		 ;;(die)
		 ))
	(loop for i below iters do
	     (when (> wait 0)
	       (let ((skip (min wait (- iters i))))
		 (decf wait skip)
		 (incf i skip))
	       (when (> wait 0)
		 (survive)))
	     (tagbody
	      next-ins
		(when (or (> ip max-ip))
		  (die "ip too large"))
		(when (<= energy 0)
		  (die "out of energy"))
		;;(when (<= (random 100000) 1)
		;;  (setf ip (random (length code))))
		(let* ((ins (aref code ip)))
		  ;;(prind energy ip ins as bs an bn off-genes)
		  (decf energy)
		  (macrolet ((make-instructions (keyform &body cases)
			       (let* ((instructions-list (mapcar #'caar cases))
				      (n-labels 4)
				      (markers-list (loop for i below n-labels collect
							 (intern (format nil "MRK~A" i))))
				      (i-list (append instructions-list markers-list))
				      (instructions (make-array (length i-list) :initial-contents i-list))
				      (instructions-hash-table (make-hash-table :test 'eq))
				      (keyform-sym (gensym)))
				 (loop for ins in i-list do
				      (assert (null (gethash ins instructions-hash-table)))
				      (setf (gethash ins instructions-hash-table) t))
				 (let ((code
					`(labels ((random-ins ()
						    (sample ,instructions))
						  (is-valid-ins (ins)
						    (multiple-value-bind (val present)
							(gethash ins ,instructions-hash-table)
						      (declare (ignore val))
						      present)))
					   (let ((,keyform-sym ,keyform))
					     (ecase ,keyform-sym
					       ,@cases
					       ((end))
					       ))
					   )))
				   ;;(prind code)
				   ;;(prind instructions)
				   code))))
		    (make-instructions
		     ins
		     ((eat)
		      (let* ((x (floor x))
			     (y (floor y))
			     (meal (ash (aref *world* x y) -2)))
			(incf energy meal)
			(decf (aref *world* x y) meal)
			(setf wait 10000)))
		     ((set-as-nil)
		      (setf as nil))
		     ((set-bs-nil)
		      (setf bs nil))
		     ((set-as-random)
		      (setf as (random-ins)))
		     ((set-bs-random)
		      (setf bs (random-ins)))
		     ((read-as)
		      (setf as (if (<= (random 2000) 0) (random-ins) (car genesx))))
		     ((read-bs)
		      (setf bs (if (<= (random 2000) 0) (random-ins) (car genesx))))
		     ((read-next)
		      (setf genesx (cdr genesx)))
		     ((write-as)
		      (when (is-valid-ins as)
			(when (> off-length 100000)
			  (die "offspring too big"))
			(let ((r (random 2000)))
			  (cond ((<= r 1) (push (random-ins) off-genes) (push as off-genes) (incf off-length 2))
				((<= r 3) (push as off-genes) (push (random-ins) off-genes) (incf off-length 2))
				((<= r 6) nil)
				(t (push as off-genes) (incf off-length))))))
		     ((write-bs)
		      (when (is-valid-ins bs)
			(when (> off-length 100000)
			  (die "offspring too big"))
			(let ((r (random 2000)))
			  (cond ((<= r 1) (push (random-ins) off-genes) (push bs off-genes) (incf off-length 2))
				((<= r 3) (push bs off-genes) (push (random-ins) off-genes) (incf off-length 2))
				((<= r 6) nil)
				(t (push bs off-genes) (incf off-length))))))
		     ((cmp-as-as-bs)
		      (setf as (eq as bs)))
		     ((cmp-as-gt-an-bn)
		      (setf as (> an bn)))
		     ((cmp-as-gt-bn-an)
		      (setf as (> bn an)))
		     ((cmp-bs-as-bs)
		      (setf bs (eq as bs)))
		     ((cmp-bs-gt-an-bn)
		      (setf bs (> an bn)))
		     ((cmp-bs-gt-bn-an)
		      (setf bs (> bn an)))
		     ((jne0)
		      (when (not as)
			(let* ((jump-ip (cdr (assoc 0 markers)))) ;0 because of JNE_0_
			  (setf ip jump-ip)
			  (if (<= 0 ip max-ip)
			      (go next-ins)
			      (die "invalid jump target")))))
		     ((jne1)
		      (when (not as)
			(let* ((jump-ip (cdr (assoc 1 markers)))) ;0 because of JNE_0_
			  (setf ip jump-ip)
			  (if (<= 0 ip max-ip)
			      (go next-ins)
			      (die "invalid jump target")))))
		     ((jne2)
		      (when (not as)
			(let* ((jump-ip (cdr (assoc 2 markers)))) ;0 because of JNE_0_
			  (setf ip jump-ip)
			  (if (<= 0 ip max-ip)
			      (go next-ins)
			      (die "invalid jump target")))))
		     ((jmp0)
		      (let* ((jump-ip (cdr (assoc 0 markers)))) ;0 because of JNE_0_
			(setf ip jump-ip)
			(if (<= 0 ip max-ip)
			    (go next-ins)
			    (die "invalid jump target"))))
		     ((jmp1)
		      (let* ((jump-ip (cdr (assoc 1 markers)))) ;0 because of JNE_0_
			(setf ip jump-ip)
			(if (<= 0 ip max-ip)
			    (go next-ins)
			    (die "invalid jump target"))))
		     ((jmp2)
		      (let* ((jump-ip (cdr (assoc 2 markers)))) ;0 because of JNE_0_
			(setf ip jump-ip)
			(if (<= 0 ip max-ip)
			    (go next-ins)
			    (die "invalid jump target"))))
		     ((set-an-1)
		      (setf an 1))
		     ((set-bn-1)
		      (setf bn 1))
		     ((set-an--1)
		      (setf an -1))
		     ((set-bn--1)
		      (setf bn -1))
		     ((set-an-to-bn)
		      (setf an bn))
		     ((set-bn-to-an)
		      (setf bn an))
		     ((set-an-to-energy)
		      (setf an energy))
		     ((set-bn-to-energy)
		      (setf bn energy))
		     ((set-an-to-angle)
		      (setf an (clamp (floor (* 128 angle)) most-negative-fixnum most-positive-fixnum)))
		     ((set-bn-to-angle)
		      (setf bn (clamp (floor (* 128 angle)) most-negative-fixnum most-positive-fixnum)))
		     ((set-angle-to-an)
		      (setf angle (/ an 128)))
		     ((set-angle-to-bn)
		      (setf angle (/ bn 128)))
		     ((add-to-an-bn)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf an (the fixnum (+ an bn)))))
		     ((add-to-bn-an)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf bn (the fixnum (+ an bn)))))
		     ((mul-to-an-bn)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf an (the fixnum (* an bn)))))
		     ((mul-to-bn-an)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf bn (the fixnum (* an bn)))))
		     ((sub-from-an-bn)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf an (the fixnum (- an bn)))))
		     ((sub-from-bn-an)
		      (locally (declare (optimize (debug 0) (safety 0) (speed 3)) (type fixnum an bn))
			(setf bn (the fixnum (- bn an)))))
		     ((sign-an)
		      (setf an (signum an)))
		     ((sign-bn)
		      (setf bn (signum bn)))
		     ((in-an-energy-left)
		      (let* ((radius (clamp (/ an 128) 0 3))
			     (x (mod (+ x (* (cos (- angle pi/2)) radius)) world-w))
			     (y (mod (+ y (* (sin (- angle pi/2)) radius)) world-h)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-an-energy-right)
		      (let* ((radius (clamp (/ an 128) 0 3))
			     (x (mod (+ x (* (cos (+ angle pi/2)) radius)) world-w))
			     (y (mod (+ y (* (sin (+ angle pi/2)) radius)) world-h)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-bn-energy-left)
		      (let* ((radius (clamp (/ bn 128) 0 3))
			     (x (mod (+ x (* (cos (- angle pi/2)) radius)) world-w))
			     (y (mod (+ y (* (sin (- angle pi/2)) radius)) world-h)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-bn-energy-right)
		      (let* ((radius (clamp (/ bn 128) 0 3))
			     (x (mod (+ x (* (cos (+ angle pi/2)) radius)) world-w))
			     (y (mod (+ y (* (sin (+ angle pi/2)) radius)) world-h)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-an-energy-x+)
		      (let ((x (mod (+ x 3) world-w)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-an-energy-x-)
		      (let ((x (mod (- x 3) world-w)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-an-energy-y+)
		      (let ((y (mod (+ y 3) world-h)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-an-energy-y-)
		      (let ((y (mod (- y 3) world-h)))
			(setf an (aref *world* (floor x) (floor y)))))
		     ((in-bn-energy-x+)
		      (let ((x (mod (+ x 3) world-w)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-bn-energy-x-)
		      (let ((x (mod (- x 3) world-w)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-bn-energy-y+)
		      (let ((y (mod (+ y 3) world-h)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-bn-energy-y-)
		      (let ((y (mod (- y 3) world-h)))
			(setf bn (aref *world* (floor x) (floor y)))))
		     ((in-angle-an)
		      (setf an (round (* 128 (mod angle (* pi 2))))))
		     ((in-angle-bn)
		      (setf bn (round (* 128 (mod angle (* pi 2))))))
		     ((set-as-an-gt0)
		      (setf as (> an 0)))
		     ((set-as-an-ge0)
		      (setf as (>= an 0)))
		     ((set-an-max-an-bn)
		      (setf an (max an bn)))
		     ((set-bn-max-an-bn)
		      (setf bn (max an bn)))
		     ((split-cell-an)
		      (when (and (>= an 0) (>= energy an))
			(cell-division x y an)))
		     ((split-cell-bn)
		      (when (and (>= bn 0) (>= energy bn))
			(cell-division x y bn)))
		     ((turn-cw-an)
		      (incf angle (/ an 128))
		      (setf wait 300))
		     ((turn-cw-bn)
		      (incf angle (/ bn 128))
		      (setf wait 300))
		     ((turn-ccw-an)
		      (decf angle (/ an 128))
		      (setf wait 300))
		     ((turn-ccw-bn)
		      (decf angle (/ bn 128))
		      (setf wait 300))
		     ((walk-an)
		      (let* ((speed (clamp (/ an 128) -1 1))
			     (new-x (my-mod (+ x (* (cos angle) speed)) world-w))
			     (new-y (my-mod (+ y (* (sin angle) speed)) world-h)))
			(incf walk-sum (abs speed)) (incf walk-count)
			(when (>= (aref *world* (floor new-x) (floor new-y)) 0)
			  (decf energy (max 0 (floor (expt (* (abs speed) 16) 2))))
			  (setf x new-x y new-y)))
		      (setf wait 100))
		     ((walk-bn)
		      (let* ((speed (clamp (/ an 128) -1 1))
			     (new-x (my-mod (+ x (* (cos angle) speed)) world-w))
			     (new-y (my-mod (+ y (* (sin angle) speed)) world-h)))
			(incf walk-sum (abs speed)) (incf walk-count)
			(when (>= (aref *world* (floor new-x) (floor new-y)) 0)
			  (decf energy (max 0 (floor (expt (* (abs speed) 16) 2))))
			  (setf x new-x y new-y)))
		      (setf wait 100))
		     ((set-angle-right)
		      (setf angle 0))
		     ((set-angle-down)
		      (setf angle (/ pi 2)))
		     ((set-angle-left)
		      (setf angle pi))
		     ((set-angle-up)
		      (setf angle (* pi 3/2)))
		     ((wait-an)
		      (setf wait (clamp (floor an) 0 10000000))
		      )
		     ((wait-bn)
		      (setf wait (clamp (floor bn) 0 10000000))
		      )
		     ((set-target-near)
		      ;;(prind "set-target-near")
		      (let* ((other (nearest-orgap x y *orgs* :exclude-orgs (list orgcont))))
			(when other
			  (setf target other)
			  (setf (orgap-targeter (orgcont-orgap other)) orgcont))))
		     ((set-angle-to-target)
		      ;;(prind "set-angle-to-target")
		      (when target
			(let* ((target-orgap (orgcont-orgap target))
			       (tenergy (orgap-energy target-orgap)))
			  (when (< tenergy 0)
			    (setf target nil))
			  (when target
			    (let* ((diff-x (- (orgap-x target-orgap) x))
				   (diff-y (- (orgap-y target-orgap) y)))
			      (setf angle (atan diff-y diff-x)))))))
		     ((set-angle-to-targeter)
		      ;;(prind "set-angle-to-targeter")
		      (when targeter
			(let* ((target-orgap (orgcont-orgap targeter))
			       (tenergy (orgap-energy target-orgap)))
			  (when (< tenergy 0)
			    (setf targeter nil))
			  (when targeter
			    (let* ((diff-x (- (orgap-x target-orgap) x))
				   (diff-y (- (orgap-y target-orgap) y)))
			      (setf angle (atan diff-y diff-x)))))))
		     ((attack-target)
		      (when target
			;;(prind "attack-target")
			(let* ((target-orgap (orgcont-orgap target))
			       (tenergy (orgap-energy target-orgap)))
			  (when (<= tenergy 0)
			    (setf target nil))
			  (when target
			    (let* ((tx (orgap-x target-orgap))
				   (ty (orgap-y target-orgap))
				   (diff-x (- tx x))
				   (diff-y (- ty y)))
			      (when (and (< (abs diff-x) .5) (< (abs diff-y) .5))
				(decf (orgap-skin target-orgap))
				(incf wait 3000)
				(when (<= (orgap-skin target-orgap) 0)
				  ;;(prind "attack kill" energy tenergy)
				  ;;(setf *cursor* orgcont)
				  (incf kills)
				  (let (;;(tx (floor tx))
					;;(ty (floor ty))
					)
				    (incf wait 10000)
				    (incf energy tenergy)
				    (setf (orgap-energy target-orgap) 0)))))))))
		      ))
		  (assert (and (typep an 'fixnum) (typep bn 'fixnum)) (an bn) "AN:~A or BN:~A are not of type FIXNUM (last INS:~A)." an bn ins)
		  )
		(incf ip)))
	(survive)
	))))

(defun orgap-code-length (org)
  (array-dimension (orgap-code org) 0))

;; the slot accessors for ORGAP do not have to be defined.

;;; end of organism implementation
