(load "~/quicklisp/setup.lisp")
(ql:quickload :alexandria)

;;;; Cards

(defstruct normal-card
  (name "" :type string)
  (symbol :undef :type symbol)
  (dice 0 :type list) ;list of (integer 1 12)
  (cost -1 :type (and unsigned-byte fixnum))
  (activation :undef :type (member :any :self))
  (color :undef :type symbol)
  (description "" :type string)
  (edition "" :type string))

(defstruct large-card
  (name "" :type string)
  (symbol :undef :type (eql :large))
  (cost -1 :type (and unsigned-byte fixnum))
  (description "" :type string)
  (edition "" :type string))

(load "/home/toni/lisp/machikoro-cards.lisp") ;generated by machikoro-parse-cards.py

;;;; Editions

(defstruct edition
  (normal-cards nil :type sequence) ;sequence of NORMAL-CARDs
  (large-cards nil :type sequence) ;sequence of LARGE-CARDs
  (number-normal-cards nil :type sequence) ;sequence of INTEGERs
  (map-normal-card-function (constantly nil) :type (function (normal-card) integer)) ;function mapping NORMAL-CARD to its index
  (map-large-card-function (constantly nil) :type (function (large-card) integer)) ;function mapping LARGE-CARD to its index
  (map-number-function (constantly nil) :type (function (integer) (or normal-card large-card))) ;function mapping card number to NORMAL-CARD or LARGE-CARD
  (starting-cards #() :type (array integer))) ;an array of size (+ (length NORMAL-CARDS) (length LARGE-CARDS)), with each element being the number of cards with that index

(defmacro defedition (name normal-cards normal-cards-total-number large-cards starting-cards)
  (declare (type symbol name))
  (alexandria:once-only ((nc normal-cards)
			 (lc large-cards)
			 (nctot normal-cards-total-number)
			 starting-cards)
    (alexandria:with-gensyms (map-nc-fn map-lc-fn map-n-fn card number nc-length lc-length sc)
      `(let* ((,nc-length (length ,nc))
	      (,lc-length (length ,lc))
	      (,sc (make-array (+ ,nc-length ,lc-length) :initial-element 0)))
	 (flet ((,map-nc-fn (,card)
		  (declare (type normal-card ,card))
		  (let ((,number (position ,card ,nc :test #'equalp)))
		    (assert (integerp ,number) () "Cannot find ~S in the normal-cards of edition ~S" ,card ,name)
		    ,number))
		(,map-lc-fn (,card)
		  (declare (type large-card ,card))
		  (let ((,number (position ,card ,lc :test #'equalp)))
		    (assert (integerp ,number) () "Cannot find ~S in the large-cards of edition ~S" ,card ,name)
		    (+ ,nc-length ,number)))
		(,map-n-fn (,number)
		  (declare (type integer ,number))
		  (assert (and (<= 0 ,number) (< ,number (+ ,nc-length ,lc-length))) () "Card number out ~S of range (0 ~S) in edition ~S" ,number (+ ,nc-length ,lc-length) ,name)
		  (if (< ,number ,nc-length)
		      (elt ,nc ,number)
		      (elt ,lc (- ,number ,nc-length)))))
	   (mapcar (lambda (,card) (assert (typep ,card 'normal-card))) ,nc)
	   (mapcar (lambda (,card) (assert (typep ,card 'large-card))) ,lc)
	   (loop for ,card in ,starting-cards do
		(incf (aref ,sc (,map-nc-fn ,card))))
	   (defconstant ,name
	     (make-edition :normal-cards ,nc
			   :large-cards ,lc
			   :number-normal-cards ,nctot
			   :map-normal-card-function #',map-nc-fn
			   :map-large-card-function #',map-lc-fn
			   :map-number-function #',map-n-fn
			   :starting-cards ,sc)))))))

(let ((nc '(("Stadion" . 4) ("Fernsehsender" . 4) ("Bürohaus" . 4)
	    ("Bergwerk" . 6) ("Apfelplantage" . 6) ("Bäckerei" . 6) ("Mini-Markt" . 6) ("Molkerei" . 6) ("Möbelfabrik" . 6) ("Markthalle" . 6) ("Weizenfeld" . 6) ("Bauernhof" . 6) ("Wald" . 6) ("Familienrestaurant" . 6) ("Café" . 6)))
      (lc '("Bahnhof" "Einkaufszentrum" "Freizeitpark" "Funkturm"))
      (sc '("Weizenfeld" "Bäckerei")))
  (flet ((card-name-to-instance (name)
	   (or (find name +normal-cards+ :test 'equal :key #'normal-card-name)
	       (find name +large-cards+ :test 'equal :key #'large-card-name))))
    (defedition base-edition
	(mapcar #'card-name-to-instance (mapcar #'car nc))
      (mapcar #'cdr nc)
      (mapcar #'card-name-to-instance lc)
      ;;TODO: FIXME: allow large card names here as well)
      (mapcar #'card-name-to-instance sc))))

;;;; Game

(defstruct player
  (cards #() :type (array integer)) ;array of INTEGERs, each integer being the number of cards with that card index (in the edition of the game currently played).
  (coins 3 :type integer))

(defstruct game
  (edition nil :type edition)
  (players #() :type (array player)) ;list of PLAYERs
  (stack #() :type (array integer)) ;array of INTEGERs, with the index of the array being the normal card number and the value equal to the number of available cards of that normal card type
  (deck nil :type list)) ;list of normal card numbers

(defun deal-card! (game)
  "Deal one card from the deck of the GAME to the stack of the GAME.
Returns whether the type of the dealt card was already present in the stack or not."
  (let* ((stack (game-stack game))
	 (new-card-number (pop (game-deck game)))
	 (new-card-stack-number (aref stack new-card-number)))
    (incf (aref stack new-card-number))
    (/= 0 new-card-stack-number)))

(defun make-new-game (edition stack-size num-players starting-coins)
  "Make a new game with EDITION, STACK-SIZE different cards in the starting stack, NUM-PLAYERS having STARTING-COINS each."
  (flet ((make-new-player (starting-coins)
	   (make-player :cards (alexandria:copy-array (edition-starting-cards edition)) :coins starting-coins))
	 (shuffle! (seq)
	   (let ((length (length seq)))
	     (loop for i below (1- length) do
		  (let* ((j (+ i 1 (random (- length i 1))))
			 (i-elt (elt seq i))
			 (j-elt (elt seq j)))
		    (setf (elt seq i) j-elt (elt seq j) i-elt))))
	   seq))
    (let* ((deck (shuffle! (alexandria:flatten (loop for i from 0 for n in (edition-number-normal-cards base-edition) collect (loop for x below n collect i)))))
	   (players-list (loop for i below num-players collect (make-new-player starting-coins)))
	   (players (make-array num-players :initial-contents players-list))
	   (number-normal-cards (length (edition-normal-cards edition)))
	   (game (make-game :edition edition
			    :players players
			    :stack (make-array number-normal-cards :initial-element 0)
			    :deck deck)))
      (loop until (or (null (game-deck game)) (= stack-size 0)) do
	   (when (not (deal-card! game))
	     (decf stack-size)))
      game)))

(defun print-game (game)
  (declare (optimize (debug 3)))
  (labels ((print-stack (stack-array)
	     (let* ((edition (game-edition game))
		    (cards (loop for card-number from 0 for count across stack-array collect
				(funcall (edition-map-number-function edition) card-number)))
		    (normal-cards (remove-if (complement #'normal-card-p) cards))
		    (large-cards (remove-if (complement #'large-card-p) cards)))
	       (setf normal-cards (sort normal-cards #'< :key (lambda (x) (car (normal-card-dice x)))))
	       (setf large-cards (sort large-cards #'< :key #'large-card-cost))
	       (flet ((card-count (card)
			(aref stack-array
			      (if (typep card 'normal-card)
				  (funcall (edition-map-normal-card-function edition) card)
				  (funcall (edition-map-large-card-function edition) card)))))
		 (let ((printed-cards 0))
		   (loop for card in normal-cards do
			(let ((count (card-count card)))
			  (when (> count 0)
			    (when (and (/= printed-cards 0) (= (mod printed-cards 3) 0))
			      (format t "~%"))
			    (incf printed-cards)
			    (format t "  ~A~S:~S" (normal-card-name card) (normal-card-dice card) count)))))
		 (format t "  ")
		 (loop for card in large-cards do
		      (let ((count (card-count card)))
			(when (> count 0)
			  (format t " ~A" (large-card-name card)))))))))
    (format t "Game stack:~%")
    (print-stack (game-stack game))
    (loop
       for player-number from 0
       for player across (game-players game) do
	 (format t "~%Player ~S (~S coins):~%" player-number (player-coins player))
	 (print-stack (player-cards player)))
    (format t "~%")))

(defun edition-game-card (game card-number)
  (funcall (edition-map-number-function (game-edition game)) card-number))

(defun buy-card! (game player-number card-number)
  (declare (optimize (debug 3)))
  (let* ((stack (game-stack game))
	 (player (aref (game-players game) player-number))
	 (edition (game-edition game))
	 (card (funcall (edition-map-number-function edition) card-number))
	 (cost (if (typep card 'normal-card) (normal-card-cost card) (large-card-cost card)))
	 (player-cards (player-cards player)))
    (assert (or (typep card 'large-card) (> (aref stack card-number) 0)) () "No ~S card left in game card stack!" card)
    (assert (>= (player-coins player) cost) () "Player ~S needs ~S coins to buy card ~S, but has only ~S left." player-number cost card (player-coins player))
    (decf (player-coins player) cost)
    ;; TODO: check that the player may have only 1 of some cards.
    (let ((card (edition-game-card game card-number)))
      (when (and (typep card 'normal-card) (eq (normal-card-color card) :pink))
	(assert (= 0 (aref player-cards card-number)) () "Player ~S wants to buy the pink card ~S, but already has ~S of them." player-number card (aref player-cards card-number)))
      (when (typep card 'large-card)
	(assert (= 0 (aref player-cards card-number)) () "Player ~S wants to buy the large card ~S, but already has ~S of them." player-number card (aref player-cards card-number))))
    (incf (aref player-cards card-number))
    (when (typep card 'normal-card)
      (decf (aref stack card-number))
      (when (<= (aref stack card-number) 0)
	;; redeal cards until at least one more type of card is dealt.
	(loop do
	     (if (null (game-deck game))
		 (return)
		 (when (not (deal-card! game))
		   (return))))))))

;; Example:
(let ((game (make-new-game base-edition 15 2 12)))
  (print-game game)
  (buy-card! game 0 0)
  (buy-card! game 1 4)
  (print-game game))
