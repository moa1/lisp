;; search for words in a text using a deterministic finite automaton

(asdf:oos 'asdf:load-op :utils)
(use-package :utils)

;;(defparameter words (read-lines "/home/toni/soft/devel/celprofile/probeblaster/example-words"))
(defparameter words (read-lines "/home/toni/soft/devel/celprofile/probeblaster/HG-U133A_probe"))

(defparameter input (open "/home/toni/soft/devel/celprofile/probeblaster/example-inp"))
;;(defparameter input (open "/home/toni/soft/devel/celprofile/probeblaster/gene_sequences.txt.first1k"))

(defun prefixlist (word &optional (all nil))
  (let ((len (length word)))
    (labels ((rec (i prefixes)
	       (if (>= i (if all (1+ len) len))
		   (nreverse prefixes)
		   (let ((p (make-array i
					:displaced-to word
					:element-type 'character)))
		     (rec (1+ i) (cons p prefixes))))))
      (rec 1 nil))))

(defun prefix-1 (word)
  (make-array (1- (length word)) :displaced-to word :element-type 'character))

(defun prefix+1 (word)
  (make-array 1 :displaced-to word :element-type 'character))

(defun suffix-1 (word)
;;  (elt word (1- (length word))))
  (make-array 1 :displaced-to word :displaced-index-offset (1- (length word))
	      :element-type 'character))

(defun prefixlist-all (word)
  (prefixlist word t))

(defun suffixlist (word)
  (let ((len (length word)))
    (labels ((rec (i suffixes)
	       (if (<= i 0)
		   (nreverse suffixes)
		   (let ((p (make-array i
					:displaced-to word
					:displaced-index-offset (- len i)
					:element-type 'character)))
		     (rec (1- i) (cons p suffixes))))))
      (rec len nil))))

(defun prefix-list (words)
  (format t "generating prefix list~%")
  (apply #'append (mapcar #'prefixlist-all words)))

(defun generate-one-letter-net (words)
  (format t "generating one letter net~%")
  (let ((net (make-hash-table :test #'equal)))
    (setf (gethash nil net) (make-hash-table :test #'equal))
    (dolist (p (unique (mapcar (lambda (x) (prefix+1 x)) words)) net)
      (setf (gethash p (gethash nil net)) p)
      (setf (gethash p net) (make-hash-table :test #'equal)))))

(defun inverse-prefix-mapping (prefixes)
  (format t "generating inverse prefix mapping~%")
  (let ((ht (make-hash-table :test #'equal)))
    (dolist (p prefixes ht)
      (let* ((p1 (prefix-1 p)))
	(setf (gethash p1 ht) (cons p (gethash p1 ht)))))))

(defun generate-net (words)
  (let* ((prefixes (prefix-list words))
	 (hp1 (inverse-prefix-mapping prefixes))
	 (net (generate-one-letter-net words)))
    (format t "generating net~%")
    (dolist (p prefixes net)
;;      (prind p)
      (dolist (s (suffixlist p))
;;	(prind s)
	(dolist (p2 (gethash s hp1))
;;	  (prind p2)
	  (let ((suffix (suffix-1 p2)))
;;	    (prind suffix (gethash p net))
	    (when (not (2nd-value (gethash suffix (gethash p net))))
;;	      (prind "suffix not in net[p]")
	      (setf (gethash suffix (gethash p net)) p2)
	      (when (not (2nd-value (gethash p2 net)))
		(setf (gethash p2 net) (make-hash-table :test #'equal))))))))))

(defun generate-emit-table (words net)
  (let ((emit (make-hash-table :test 'equal))
	(wordh (make-hash-table :test 'equal)))
    (dolist (w words)
      (setf (gethash w wordh) t))
    (maphash (lambda (p v)
	       (declare (ignore v))
	       (let ((sl (suffixlist p)))
		 (dolist (s sl)
		   (when (2nd-value (gethash s wordh))
		     (setf (gethash p emit) (cons s (gethash p emit)))))))
	     net)
    emit))

(defun run-net (net emit stream)
  (do ((c (read-char stream) (read-char stream nil 'the-end))
       (state nil))
      ((not (characterp c)))
    (let ((sc (make-string 1 :initial-element c)))
;;      (prind state sc)
      (if (2nd-value (gethash sc (gethash state net)))
	  (setf state (gethash sc (gethash state net)))
	  (if (2nd-value (gethash sc (gethash nil net)))
	      (setf state (gethash sc (gethash nil net)))
	      (setf state nil)))
      (when (gethash state emit)
;;	(prind (gethash state emit))))))
	nil))))

(defun create-net-and-run (words stream)
  (let* ((net (generate-net words))
	 (emit (generate-emit-table words net)))
    (timeit (1) (run-net net emit stream))))

;;(create-net-and-run words *standard-input*)
(create-net-and-run words input)
